## 分类

* 基本（值）数据类型

  * String
  * Number
  * boolean
  * undefined
  * null

* 引用\(对象\)数据类型

  * object:任意对象
  * Function：一种特别的对象
  * Array： 一种特别的对象（数值下标，内部数据是有序的），**数组也是对象**

## 判断数据的类型

* typeof    可以判断：undefined/数值/字符串 / 布尔值/function
  * 不能判断null和undefined  ，Object与arry
* instanceof 判断对象的具体类型
* ===   可以判断undefined null

## 数据、变量、内存的理解

* 什么是数据
  * 在内存中可读的，可传递的保存了特定信息的“东东”
  * 一切皆数据，函数也是数据
  * 在内存中的所有操作的目标：数据
* 什么是变量
  * 在程序运行过程中它的值是允许改变的量
  * 一个变量对应一块小内存，它的值保存在此内存中
* 什么是内存

  * 内存条通电后产生的存储空间（临时的）。硬盘的存储空间是持久的

    * 产生和死亡：内存条（集成电路板）==》通电==》产生一定容量的存储空间==》存储各种数据==》断电==》内存全部消亡

  * 一块内存包含2个方面的数据

    * 内部存储的数据
    * 地址值数据

  * 三者之间的关系

    * 内存是容器，用来存储不同数据
    * 变量是内存的标识，通过变量我们可以操作（读/写）内存中的数据

* 内存的分类

  * 栈 ：存储全局变量和局部变量（空间比较小）
  * 堆：对象（空间比较大）

### 关于引用变量赋值的问题

* 两个或多个引用变量指向同一个对象，通过一个变量修改对象内部数据，另一个变量看到的 是修改之后的数据
* 两个引用变量指向同一个对象，让其中一个引用变量指向另一个对象，另一引用变量依然指向前一个对象

### 赋值等号左边的是写属性右边的是读

### js引擎如何管理内存

* 1 内存生命周期
  * 分配小内存空间，得到它的使用权
  * 存储数据，可以反复进行操作
  * 释放小内存空间
* 释放内存
  * 局部变量：函数执行完毕自动释放
  * 对象：成为垃圾对象==》垃圾对象回收

### 什么时候必须使用【‘属性名’】的方式

* 属性名包含特殊字符：-  空格 等
* 属性名不确定 例如变量是变量名。例如  
  var p={}

  p\['content-type'\]= "text/josn"

  console.log\(p\['content-type'\]\)

  var propName ="myge"

  var value =18

  p\['propName'\]=value

### 对象

* 代表现实中的某个事物，是该事物在编程中的抽象
* 多个数据的集合体（封装体）
* 用于保存多个数据的容器

##### 为什么要用对象

* 便于对多个数据进行统一管理

##### 对象的组成

* 属性
  * 代表现实事物的状态数据
  * 由属性名和属性值组成
  * 属性名都是字符串类型，属性值是任意类型
* 方法
  * 代表现实事物的行为数据
  * 是特别的属性==》属性值是函数

##### 如何访问对象内部数据

* 属性名：编码简单，但有时不能用 
* \['属性名'\]：编码麻烦，但是通用

### 函数的理解和使用

* ##### 什么是函数?
* ##### 用来实现特定功能的, n条语句的封装体
* 只有函数类型的数据是可以执行的, 其它的都不可以

## 为什么要用函数?

\* 提高复用性

\* 便于阅读交流

\* 函数也是对象

\* instanceof Object===true

\* 函数有属性: prototype

\* 函数有方法: call\(\)/apply\(\)

\* 可以添加新的属性/方法

## 函数的3种不同角色

\* 一般函数 : 直接调用

\* 构造函数 : 通过new调用

\* 对象 : 通过.调用内部的属性/方法

## 函数中的this

\* 显式指定谁: obj.xxx\(\)

\* 通过call/apply指定谁调用: xxx.call\(obj\)

\* 不指定谁调用: xxx\(\)  : window

\* 回调函数: 看背后是通过谁来调用的: window/其它

## 匿名函数自调用:

\`\`\`

\(function\(w, obj\){

```
//实现代码
```

}\)\(window, obj\)

\`\`\`

\* 专业术语为: IIFE \(Immediately Invoked Function Expression\) 立即调用函数表达式

### 回调函数的理解

#### 什么函数才是回调函数?

* 你定义的

* 你没有调用

* 但它最终执行了\(在一定条件下或某个时刻\)

### 常用的回调函数

* dom事件回调函数==》如果调用this this是发生事件的dom元素

* 定时器回调函数

* ajax请求回调函数\(后面讲解\)

* 生命周期回调函数\(后面讲解\)

### 形参和实参

* 形参：是一个变量而且是一个局部变量

* 实参：实际上是数据  或变量的值

#### 变量的提升与函数的提升

* 变量提升和函数提升是如何产生的
* * 变量声明提升

  * 1. 通过var定义（声明）的变量，在定义语句之前就可以访问到
    2. 值：undefined
  * 函数声明提升
    * 通过function声明的函数，在之前就可以直接调用
    * 值：函数的定义（对象）

#### 执行上下文

* 代码分类\(位置\)

  * 全局代码
  * 函数代码

* 全局执行上下文

  * 在执行全局代码前将window确定为全局执行上下文
  * 对全局数据进行预处理

  * var定义的全局变量==&gt;undefined, 添加为window的属性

  * function声明的全局函数==&gt;赋值\(fun\), 添加为window的方法
  * this==&gt;赋值\(window\)
  * 开始执行全局代码

* 函数执行上下文

  * 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象
  * 对局部数据进行预处理
  * 形参变量==&gt;赋值\(实参\)==&gt;添加为执行上下文的属性
  * arguments==&gt;赋值\(实参列表\), 添加为执行上下文的属性
  * var定义的局部变量==&gt;undefined, 添加为执行上下文的属性
  * function声明的函数 ==&gt;赋值\(fun\), 添加为执行上下文的方法
  * this==&gt;赋值\(调用函数的对象\)
  * 开始执行函数体代码



