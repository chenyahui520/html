#### 函数的prototype属性（图）

* 每个函数都有一个prototype属性，它默认指向一个Object空对象（即成为：原型对象）
* 原型对象中有一个属性constructor，它指向函数对象

#### 给原型对象添加属性（一般都是方法）

* 作用：函数的所有实例对象自动拥有原型中的属性（方法）；\(原型继承\)利用的就是原型链的得到的

### 原型与原型链

* ###### **所有函数都有一个特别的属性**

  ###### - ‘prototype’：显示原型属性
* 所有实例对象都有一个特别的属性：
  * ‘\_\__proto_\_\_’:隐式原型对象。
* 对象的隐式原型的值为其对应构造函数的显式原型的值
* 显示原型与隐式原型的关系
  * 函数的prototype:定义函数时被自动赋值，值默认为「」\(空Object对象\)，即用为原型对象
  * 实例对象的\_\__proto_\_\_：在创建实例对象时被自动添加，并赋值为构造函数的prototype值
  * 原型对象即为当前实例对象的父对象（对象的隐式原型的值为其对应构造函数的显式原型的值
    * ）
* 原型链
  * 所有的实例对象都有\_\_proto\_\_属性，它指向的就是原型对象
  * 这样通过proto属性就形成了一个链的结构==》原型链
  * 当给对象属性赋值时不会使用原型链，而只是在当前对象中进行操作 
* 程序员能直接操作显示原型，但不能直接操作隐式原型（es6）之前

### \*\*\*原型链  、原型对象 对象实例的关系图

* **所有函数都是Function的实例（包含Function）所以函数都有proto\_\_属性，**

* **所有函数的显示原型的隐式原型指向默认是空Object实例对象（但Object不满足）也可以说所有我们定义的函数，它的原型对象都是Object的实例图5**

* **所有函数对象本身的隐式原型都指向Function的显示原型  图4**

  * **所有函数的显示原型和隐式原型都不相等，Function除外**

* * **Object的原型对象是原型链尽头**

![](/assets/5.png)

1.读取对象的属性值时：会自动到原型链中查找

2.设置对象的属性值时：不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值

3.方法一般定义在原型中，属性一般通过构造函数定义在对象本身上

#### instanceOf是如何判断的？

* 表达式：A instanceOf  B
* 如果B函数的显示原型对象在A对象的原型链上，返回true，否则返回flase \(即A是否为B的实例对象\)



